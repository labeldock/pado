{"version":3,"sources":["../.src/modules/session.js"],"names":["SESSION_STORE","STATE_STORE","session","name","inst","outputs","map","e","output","open","fn","close","result","Promise","all","spawn","payload","Error","input","promise","valueOf","managedSpawn","undefined","item","then","deferred","defer","deferPromise","push","resolve","reject"],"mappings":";;;;;;;;;;;;;;;;;;;AAEA,MAAMA,gBAAgB,EAAtB;AACA,MAAMC,cAAgB,EAAtB;AAEA;;;;;;;;;;;;;AAaO,MAAMC,UAAU,SAAVA,OAAU,CAAUC,IAAV,EAAe;AACpC,QAAMC,OAAO;AACXC,eAAS;AAAA,eAAIJ,YAAYE,IAAZ,EAAkBG,GAAlB,CAAsB;AAAA,iBAAGC,EAAEC,MAAL;AAAA,SAAtB,CAAJ;AAAA,OADE;AAEXC,YAAS,cAACC,EAAD,EAAM;AACbV,sBAAcG,IAAd,IAAsBO,EAAtB;AACAT,oBAAYE,IAAZ,IAAoB,EAApB;AACD,OALU;AAMXQ,aAAO,iBAAI;AACT,YAAMC,SAASR,KAAKC,OAAL,EAAf;AACA,eAAOL,cAAcG,IAAd,CAAP;AACA,eAAOF,YAAYE,IAAZ,CAAP;AACA,eAAOU,QAAQC,GAAR,CAAYF,MAAZ,CAAP;AACD,OAXU;AAYXG,aAAO,eAACC,OAAD,EAAW;AAChB,YAAG,OAAOhB,cAAcG,IAAd,CAAP,KAA+B,UAAlC,EAA6C;AAC3C,cAAG,CAACH,cAAcG,IAAd,CAAJ,EAAwB;AACtB,kBAAM,IAAIc,KAAJ,gBAAuBd,IAAvB,qBAAN;AACD,WAFD,MAEO;AACL,kBAAM,IAAIc,KAAJ,gBAAuBd,IAAvB,+BAAN;AACD;AACF;;AAED,YAAMe,QAAQC,iBAAQC,OAAR,CAAgBpB,cAAcG,IAAd,EAAoBa,OAApB,CAAhB,CAAd;;AACA,YAAMK,eAAe;AACnBH,sBADmB;AAEnBV,kBAAQc,SAFW;AAGnBC,gBAAQD;AAHW,SAArB;AAMA,eAAOJ,MAAMM,IAAN,CAAW,UAACD,IAAD,EAAQ;AACxB,cAAME,WAAgBN,iBAAQO,KAAR,EAAtB;;AACA,cAAMC,eAAgBF,SAASN,OAA/B;AACAE,uBAAab,MAAb,GAAsBmB,YAAtB;AACAN,uBAAaE,IAAb,GAAoBA,IAApB;AAEAtB,sBAAYE,IAAZ,EAAkByB,IAAlB,CAAuBP,YAAvB;AAEA,iBAAO;AACLE,sBADK;AAELM,qBAASJ,SAASI,OAFb;AAGLC,oBAASL,SAASK;AAHb,WAAP;AAKD,SAbM,CAAP;AAcD;AA1CU,KAAb;AA6CA,WAAO1B,IAAP;AACD,GA/CM","sourcesContent":["import { promise } from './promise'\n\nconst SESSION_STORE = {}\nconst STATE_STORE   = {}\n\n/*\nlet idx = 0;\nsession(\"scopeName\").open((name)=>{ id:idx++, name });\n\nlet { item, resolve } = await session(\"scopeName\").spawn(\"bob\");\nresolve(item);\n\nlet { item, resolve } = await session(\"scopeName\").spawn(\"cat\");\nresolve(item);\n\nsession(\"scopeName\").close()\n*/\n\nexport const session = function (name){\n  const inst = {\n    outputs: ()=>STATE_STORE[name].map(e=>e.output),\n    open   : (fn)=>{\n      SESSION_STORE[name] = fn\n      STATE_STORE[name] = []\n    },\n    close: ()=>{\n      const result = inst.outputs()\n      delete SESSION_STORE[name]\n      delete STATE_STORE[name]\n      return Promise.all(result)\n    },\n    spawn: (payload)=>{\n      if(typeof SESSION_STORE[name] !== \"function\"){\n        if(!SESSION_STORE[name]){\n          throw new Error(`session:: ${name} is not defined`)\n        } else {\n          throw new Error(`session:: ${name} is not function callback`)\n        }\n      }\n      \n      const input = promise.valueOf(SESSION_STORE[name](payload))\n      const managedSpawn = {\n        input,\n        output: undefined,\n        item  : undefined\n      }\n      \n      return input.then((item)=>{\n        const deferred      = promise.defer()\n        const deferPromise  = deferred.promise\n        managedSpawn.output = deferPromise\n        managedSpawn.item = item\n        \n        STATE_STORE[name].push(managedSpawn)\n        \n        return { \n          item,\n          resolve: deferred.resolve,\n          reject : deferred.reject\n        }\n      })\n    }\n  }\n  \n  return inst\n}\n"],"file":"session.js"}