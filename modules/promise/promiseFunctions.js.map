{"version":3,"sources":["../../.src/modules/promise/promiseFunctions.js"],"names":["promisify","asyncErrCallbackfn","argumentNames","slice","promisified","args","Array","from","arguments","Promise","resolve","reject","applyParams","concat","error","callbakArgs","length","reduce","dest","name","index","apply","until","tasks","option","PromiseFunction","Error","some","e","finished","defer","limit","parseInt","taskLength","wheelTick","resetScope","nextWheelTick","tick","value","tickScope","nowAction","isActiveFn","nextTickFn","passValue","next","isActive","Math","floor","setTimeout","thenStack","abort","catchStack","deferReset","resetTick","stop","forEach","promise","then","fn","catch","start","reset","wheelControls","push","batch","funcArray","opts","concurrent","Number","POSITIVE_INFINITY","interval","repeat","sequanceTaskEntries","fill","sequanceLength","sequanceComplete","sequanceReseult","output","entry","timeout","limitOutput","operate","input","result","abortMessage","Object","defineProperty","get","notifyConsole","undefined","PromiseClass","console","warn"],"mappings":"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","sourcesContent":["// promise utils\nimport { PromiseClass, newPromise } from './promiseEngine'\nimport { promise as PromiseFunction } from './promise'\nimport { asArray, asObject } from '../../functions/cast'\nimport { isNumber } from '../../functions/isLike'\nimport { turn } from '../../functions/nice'\nimport { argumentNamesBy } from '../../functions/hack'\n\nimport { operate } from '../operate'\n\nexport const promisify = function (asyncErrCallbackfn){\n  const argumentNames = argumentNamesBy(asyncErrCallbackfn).slice(1)\n  const promisified   = function (){\n    const args = Array.from(arguments)\n    return new Promise((resolve, reject)=>{\n      const applyParams = args.concat(function (){\n        const [error, ...callbakArgs] = Array.from(arguments)\n        if(error){\n          reject(error)\n        } else if(argumentNames.length && callbakArgs.length > 1){\n          resolve(argumentNames.reduce((dest, name, index)=>{\n            dest[name] = callbakArgs[index]\n            return dest\n          }, {}))\n        } else {\n          resolve(callbakArgs[0])\n        }\n      })\n      asyncErrCallbackfn.apply(this, applyParams)\n    })\n  }\n  return function (){\n    return promisified.apply(this, Array.from(arguments))\n  }\n}\n\nexport const until = function (tasks, option){\n  if(!(tasks instanceof Array)){\n    return PromiseFunction.reject(new Error(\"tasks must be array\"))\n  }\n\n  if(!tasks.length || !tasks.some(e=>typeof e === \"function\")){\n    return PromiseFunction.reject(new Error(\"not found wheel executable\"))\n  }\n\n  if(!tasks.some(e=>(typeof e !== \"function\" || typeof e !== \"number\"))){\n    return PromiseFunction.reject(new Error(\"wheel task only function or number executable\"))\n  }\n\n  if(typeof option !== \"object\"){\n    option = {}\n  }\n\n  let finished = false\n  let defer\n  const limit = (typeof option.limit === \"number\" && option.limit > 0) ? parseInt(option.limit, 10) : 10000\n  const taskLength = tasks.length\n  let wheelTick = 0\n  let resetScope = 0\n  const nextWheelTick = (tick, value, tickScope)=>{\n    const nowAction = tasks[turn(tick, taskLength, 1)]\n\n    const isActiveFn = ()=>{\n      return tickScope === resetScope\n    }\n\n    const nextTickFn = passValue=>{\n      // if reset called\n      if(!isActiveFn()) return\n      // if over tick\n      if(wheelTick > limit){\n        return defer.reject(new Error(\"limit\"))\n      }\n      if(finished === false){\n        nextWheelTick(wheelTick++, passValue, tickScope)\n      }\n    }\n\n    if(typeof nowAction === \"function\"){\n      nowAction(\n        {\n          value,\n          next    : nextTickFn,\n          isActive: isActiveFn,\n          resolve : defer.resolve,\n          reject  : defer.reject\n        },\n        Math.floor(tick / tasks.length),\n        tick\n      )\n    } else if(typeof nowAction === \"number\"){\n      setTimeout(()=>{ nextTickFn(value) }, nowAction)\n    }\n  }\n  \n  const thenStack  = [\n    e=>{\n      if(finished === null) return abort()\n      finished = true\n      return e\n    }\n  ]\n  const catchStack = [\n    e=>{\n      if(finished === null) return abort()\n      finished = true\n      return PromiseFunction.reject(e)\n    }\n  ]\n  \n  const deferReset = (resetTick)=>{\n    defer && defer.stop()\n    //\n    defer = PromiseFunction.defer()\n    thenStack.forEach(fn=>defer.promise.then(fn))\n    catchStack.forEach(fn=>defer.promise.catch(fn))\n    \n    //\n    defer.stop = ()=>{\n      finished = null\n      resetScope += 1\n    }\n    \n    defer.start = (resetTick)=>{\n      if(finished === null){\n        finished = false\n        wheelTick = typeof resetTick === \"number\" ? resetTick : 0\n        nextWheelTick(wheelTick++, option.value, resetScope)\n      }\n    }\n    //\n    defer.reset = deferReset\n    //\n    finished = null\n    defer.start(resetTick)\n  }\n  \n  deferReset(0)\n  \n  const wheelControls = {\n    ...defer,\n    then (fn){\n      defer.promise.then(fn)\n      thenStack.push(fn)\n      return wheelControls\n    },\n    catch (fn){\n      defer.promise.catch(fn)\n      catchStack.push(fn)\n      return wheelControls\n    }\n  }\n  \n  return wheelControls\n}\n\nexport const batch = function (funcArray, opts){\n  return newPromise(function (resolve, reject){\n    const option = asObject(opts, \"concurrent\")\n      \n    if(option.concurrent === true){\n      option.concurrent = Number.POSITIVE_INFINITY\n    } else if(!isNumber(option.concurrent) || option.concurrent < 1){\n      option.concurrent = 1\n    }\n      \n    if(!isNumber(option.interval) || option.interval < -1){\n      option.interval = -1\n    }\n      \n    if(!isNumber(option.repeat) || option.repeat < 1){\n      option.repeat = 1\n    }\n      \n    //set task with repeat\n    const sequanceTaskEntries = Array(option.repeat)\n    .fill(asArray(funcArray))\n    .reduce((dest, tasks)=>{\n      tasks.forEach((fn, index)=>dest.push([index, fn]))\n      return dest\n    }, [])\n      \n    const sequanceLength = sequanceTaskEntries.length\n    let sequanceComplete = 0\n    const sequanceReseult = Array(sequanceTaskEntries.length)\n      \n    operate({\n      output: async ({ entry })=>{\n        if(option.interval > -1){\n          await PromiseFunction.timeout(option.interval)\n        }\n        return entry\n      },\n      limitOutput: 1\n    })\n    .operate({\n      concurrent: option.concurrent,\n      input     : async ({ entry })=>{\n        // eslint-disable-next-line no-unused-vars\n        const [index, fn] = entry\n        entry.push(await fn())\n        return entry\n      },\n      output: ({ entry })=>{\n        // eslint-disable-next-line no-unused-vars\n        const [index, fn, result] = entry\n        \n        sequanceReseult[index] = result\n        sequanceComplete++\n        \n        if(sequanceComplete === sequanceLength){\n          resolve(sequanceReseult)\n        }\n      }\n    })\n    .concat(sequanceTaskEntries)\n  })\n}\n\n\n// abort is deprecated\nconst abortMessage = new function (){\n  Object.defineProperty(this, \"message\", {\n    get: ()=>\":abort\"\n  })\n  Object.defineProperty(this, \"abort\", {\n    get: ()=>true\n  })\n}()\n\nexport const abort = function (notifyConsole = undefined){\n  return new PromiseClass((resolve, reject)=>{\n    if(notifyConsole === true){\n      console.warn(\"abort promise\")\n    }\n    reject(abortMessage)\n  })\n}\n"],"file":"promiseFunctions.js"}